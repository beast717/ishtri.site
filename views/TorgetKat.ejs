<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="icon" href="/ishtri1.png" sizes="16x16 32x32" type="image/png"> <!-- Use root-relative path -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- SEO and Social Media Meta Tags -->
    <!-- Title Tag: Make it dynamic based on the category -->
    <title><%= typeof category !== 'undefined' ? category : 'Products' %> | Ishtri Marketplace</title>

    <!-- Meta Description: Describe the category page -->
    <meta name="description" content="Discover thousands of listings for <%= typeof category !== 'undefined' ? category : 'products' %> on Ishtri. Filter by price, location, and condition to find the perfect item for you today.">
    <!-- Keywords: Include category and related terms -->
    <meta name="keywords" content="<%= typeof category !== 'undefined' ? category : 'products' %>, Ishtri, marketplace, buy, sell, filter, sort, <%= typeof category !== 'undefined' ? category.toLowerCase() : '' %> listings">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <!-- Construct URL dynamically if possible -->
    <meta property="og:url" content="https://ishtri.site/torgetkat?category=<%= typeof category !== 'undefined' ? category : '' %>"> <!-- Replace with actual domain -->
    <meta property="og:title" content="<%= typeof category !== 'undefined' ? category : 'Products' %> | Ishtri Marketplace">
    <meta property="og:description" content="Browse and filter products in the <%= typeof category !== 'undefined' ? category : 'selected' %> category on Ishtri.">
    <meta property="og:image" content="<%= typeof product !== 'undefined' && product.Images && product.Images.split(',').length > 0 ? baseUrl + '/uploads/' + product.Images.split(',')[0].trim() : baseUrl + '/images/default-product.png' %>"> <!-- Replace with actual domain and path to a relevant image or logo -->

    <!-- Twitter -->
    <meta property="twitter:card" content="summary">
    <meta property="twitter:url" content="https://ishtri.site/torgetkat?category=<%= typeof category !== 'undefined' ? category : '' %>"> <!-- Replace with actual domain -->
    <meta property="twitter:title" content="<%= typeof category !== 'undefined' ? category : 'Products' %> | Ishtri Marketplace">
    <meta property="twitter:description" content="Browse and filter products in the <%= typeof category !== 'undefined' ? category : 'selected' %> category on Ishtri.">
    <meta property="twitter:image" content="https://ishtri.site/ishtri1.png"> <!-- Replace with actual domain and path to a relevant image or logo -->

    <!-- Other Meta Tags -->
    <meta name="robots" content="index, follow"> <!-- Allow indexing of category pages -->
    <link rel="canonical" href="<%= typeof product !== 'undefined' ? baseUrl + '/productDetails?productdID=' + product.ProductdID : baseUrl %>" /> <!-- Replace with actual domain -->

    <!-- Stylesheets and Scripts -->
    <link rel="stylesheet" href="/css/main.css"> 
    <script src="/js/toast.js" defer></script>
    <script src="/js/skeleton.js" defer></script>
    <script src="/js/backToTop.js" defer></script>
    <script src="/js/lazyLoad.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js" integrity="sha512-UOJe4paV6hYWBnS0c9GnIRH8PLm2nFK22uhfAvsTIqd3uwnWsVri1OPn5fJYdLtGY3wB11LGHJ4yPU1WFJeBYQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

          
<!-- ADD THIS SCRIPT TO THE <head> of TorgetKat.html -->
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
    "@type": "ListItem",
    "position": 1,
    "name": "Home",
    "item": "<%= baseUrl %>/"
  },{
    "@type": "ListItem",
    "position": 2,
    "name": "<%= typeof category !== 'undefined' ? category : 'Products' %>",
    "item": "<%= baseUrl %>/torgetkat?category=<%= typeof category !== 'undefined' ? category : '' %>"
  }]
}
</script>

    

</head>
<body>
    <%- include('partials/navbar') %>
    <script src="/shared.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.1/nouislider.min.js" integrity="sha512-UOJe4paV6hYWBnS0c9GnIRH8PLm2nFK22uhfAvsTIqd3uwnWsVri1OPn5fJYdLtGY3wB11LGHJ4yPU1WFJeBYQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <!-- Filter/Sort Bar (This section is OUTSIDE the main two-column layout) -->
    <div class="filter-container-wrapper" style="margin-bottom: 20px; padding-left: 25px;">
        <button class="offcanvas-filter-btn" id="offcanvasFilterBtn" type="button">
        <i class="fas fa-filter"></i> Filter
    </button>
        <div class="filter-container">
            <label for="priceFilter" data-i18n="filter.sorter_etter">Sort By:</label>
            <select id="priceFilter" onchange="applyFilters()">
                <option value="asc" data-i18n="filter.lavest_pris">Lowest Price</option>
                <option value="desc" data-i18n="filter.høyest_pris">Highest Price</option>
                <option value="" data-i18n="filter.alle">All</option>
            </select>
            <label for="dateFilter" data-i18n="filter.utgitt">Date:</label>
            <select id="dateFilter" onchange="applyFilters()">
                <option value="" data-i18n="filter.alle">All</option>
                <option value="desc" data-i18n="filter.nylige">New</option>
                <option value="asc" data-i18n="filter.eldre">Old</option>
            </select>
            <div id="subcategoryFilterContainer" style="display: none;">
                <label for="subCategoryFilter" data-i18n="form.category">Categori:</label>
                <select id="subCategoryFilter" onchange="applyFilters()">
                    <option value="" data-i18n="filter.alle">All</option>
                    <option value="Klær" data-i18n="subkategori.klær">Clothes</option>
                    <option value="Elektronikk" data-i18n="subkategori.elektronikk">Electronics</option>
                    <option value="Hvitvarer" data-i18n="subkategori.hvitvarer">White Goods</option>
                    <option value="Møbler" data-i18n="subkategori.møbler">Furniture</option>
                    <option value="Annet" data-i18n="subkategori.annet">Else</option>
                </select>
            </div>
            <div class="filter-actions">
                      
                <button id="saveSearchBtn" class="btn btn-primary save-search-button">
                    <span class="btn-icon"><i class="fas fa-save"></i></span>
                    <span class="btn-text">Save This Search</span>
                </button>
                      
                <button onclick="resetFilters()" class="btn btn-secondary reset-filters-btn" id="resetFiltersBtn">
                    <span class="btn-icon"></span>
                    <span class="btn-text">Reset Filters</span>
                </button>

    
            </div>
        </div>
    </div>

    <!-- Active Filters Display (This is also OUTSIDE the main two-column layout) -->
    <div class="active-filters-container" id="activeFiltersDisplay" style="display: none; margin-bottom: 15px; padding: 10px 20px;">
        <!-- Active filters will be shown here by JS -->
    </div>

    <!-- THIS IS THE MAIN TWO-COLUMN LAYOUT CONTAINER -->
    <div class="page-container">

        <!-- Child 1: The Side Panel (Left Column) -->
        <div class="side-panel" id="mainSidePanel">
            <h3 data-i18n="filter.filter_land">Filter by Country</h3>
            <ul class="country-list">
                <!-- Countries will be populated here -->
            </ul>
    
            <h3 id="filterCar">Filter by Car</h3>
            <ul class="car-brand-list" id="carBrandList">
                <!-- Car brands will be populated here -->
            </ul>

            <!-- Car Specific Filters -->
            <div id="carSpecificFilters" style="display: none;">
                <div class="filter-section">
                    <h4 data-i18n="filter.year_range">Year Range</h4>
                    <div class="slider-values"><span id="year-slider-val-min"></span> - <span id="year-slider-val-max"></span></div>
                    <div id="year-slider" class="range-slider"></div>
                    <input type="hidden" id="yearFrom">
                    <input type="hidden" id="yearTo">
                </div>
                <div class="filter-section">
                    <h4 data-i18n="filter.mileage_range">Mileage (km)</h4>
                    <div class="slider-values"><span id="mileage-slider-val-min"></span> - <span id="mileage-slider-val-max"></span></div>
                    <div id="mileage-slider" class="range-slider"></div>
                    <input type="hidden" id="mileageFrom">
                    <input type="hidden" id="mileageTo">
                </div>
                <div class="filter-section">
                    <h4 data-i18n="filter.fuel_type">Fuel Type</h4>
                    <select id="fuelTypeFilter" multiple>
                        <option value="Petrol" data-i18n="fuel.petrol">Petrol</option>
                        <option value="Diesel" data-i18n="fuel.diesel">Diesel</option>
                        <option value="Hybrid" data-i18n="fuel.hybrid">Hybrid</option>
                        <option value="Electric" data-i18n="fuel.electric">Electric</option>
                        <option value="Other" data-i18n="filter.other">Other</option>
                    </select>
                </div>
                <div class="filter-section">
                    <h4>Transmission</h4>
                    <select id="transmissionFilter" multiple>
                        <option value="Manual">Manual</option>
                        <option value="Automatic">Automatic</option>
                    </select>
                </div>
            </div>

            <!-- Property Specific Filters -->
            <div id="propertySpecificFilters" style="display: none;">
                <div class="filter-section">
                    <h4>Property Type</h4>
                    <select id="propertyTypeFilter" multiple>
                        <option value="Apartment">Apartment</option>
                        <option value="House">House</option>
                        <option value="Cabin">Cabin</option>
                        <option value="Townhouse">Townhouse</option>
                        <option value="Commercial">Commercial</option>
                    </select>
                </div>
                <div class="filter-section">
                    <h4>Size (m²)</h4>
                    <div class="slider-values"><span id="size-slider-val-min"></span> - <span id="size-slider-val-max"></span></div>
                    <div id="size-slider" class="range-slider"></div>
                    <input type="hidden" id="sizeSqmFrom">
                    <input type="hidden" id="sizeSqmTo">
                </div>
                <div class="filter-section">
                    <h4>Number of Rooms</h4>
                    <div class="slider-values"><span id="rooms-slider-val-min"></span> - <span id="rooms-slider-val-max"></span></div>
                    <div id="rooms-slider" class="range-slider"></div>
                    <input type="hidden" id="numRoomsFrom">
                    <input type="hidden" id="numRoomsTo">
                </div>
                <div class="filter-section">
                    <h4>Number of Bathrooms</h4>
                    <div class="slider-values"><span id="bathrooms-slider-val-min"></span> - <span id="bathrooms-slider-val-max"></span></div>
                    <div id="bathrooms-slider" class="range-slider"></div>
                    <input type="hidden" id="numBathroomsFrom">
                    <input type="hidden" id="numBathroomsTo">
                </div>
                <div class="filter-section">
                    <h4>Energy Class</h4>
                    <select id="energyClassFilter" multiple>
                        <option value="A">A</option>
                        <option value="B">B</option>
                        <option value="C">C</option>
                        <option value="D">D</option>
                        <option value="E">E</option>
                        <option value="F">F</option>
                        <option value="G">G</option>
                    </select>
                </div>
            </div>

            <!-- Work Specific Filters -->
            <div id="workSpecificFilters" style="display: none;">
                <div class="filter-section">
                    <h4>Employment Type</h4>
                    <select id="employmentTypeFilter" multiple>
                        <option value="Full-time">Full-time</option>
                        <option value="Part-time">Part-time</option>
                        <option value="Contract">Contract</option>
                        <option value="Temporary">Temporary</option>
                        <option value="Internship">Internship</option>
                    </select>
                </div>
                <div class="filter-section">
                    <h4>Salary Range (NOK)</h4>
                    <div class="range-inputs">
                        <input type="number" id="salaryFrom" placeholder="From" min="0">
                        <input type="number" id="salaryTo" placeholder="To">
                    </div>
                </div>
                <div class="filter-section">
                    <h4>Application Deadline</h4>
                    <div class="date-input">
                        <input type="date" id="deadlineDate">
                    </div>
                </div>
            </div>
             <!-- START: Added Action Buttons for Mobile -->
            <div class="offcanvas-actions">
                      
            <button id="saveSearchBtn-mobile" class="btn btn-primary save-search-button">
                <span class="btn-icon"><i class="fas fa-save"></i></span>
                <span class="btn-text">Save This Search</span>
            </button>

                     
                      
            <button onclick="resetFilters()" class="btn btn-secondary reset-filters-btn" id="resetFiltersBtn-mobile">
                <span class="btn-icon"></span>
                <span class="btn-text">Reset Filters</span>
            </button>

    
            </div>
        </div>

        <!-- Child 2: The Products Container (Right Column) -->
        <div class="productsContainer" id="productsContainer">
            <!-- Skeleton loading will be shown here -->
        </div>

    </div> <!-- End of .page-container -->

    <!-- Off-Canvas and other utility elements -->
    <div class="offcanvas-filter-overlay" id="offcanvasFilterOverlay"></div>
    <aside class="offcanvas-filter-drawer" id="offcanvasFilterDrawer" aria-modal="true" role="dialog" tabindex="-1">
        <div class="offcanvas-filter-header">
            <span class="offcanvas-filter-title"><i class="fas fa-filter"></i> Filters</span>
            <button class="offcanvas-filter-close" id="offcanvasFilterClose" aria-label="Close Filters">×</button>
        </div>
        <div class="offcanvas-filter-content">
            <div id="offcanvasSidePanel">
                <!-- Will be filled by JS with .side-panel content -->
            </div>
        </div>
    </aside>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
    </div>
    <div class="toast-container" id="toastContainer"></div>
    <div class="back-to-top" id="backToTop">
        <i class="fas fa-arrow-up"></i>
    </div>


    <script>
    document.addEventListener('DOMContentLoaded', () => {      

        // Add debouncing utility
        const debounce = (func, wait) => {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };

        // Pagination variables
        let currentPage = 1;
        let isLoading = false;
        let hasMore = true;
        const limit = 20;

        // Current filter state
        let currentFilters = {
            priceOrder: '',
            selectedCountries: [],
            dateOrder: '',
            subCategory: '',
            selectedCarBrands: [],
            selectedCities: [],
            yearRange: { from: null, to: null },
            mileageRange: { from: null, to: null },
            fuelTypes: [],
            transmissionTypes: [],
            propertyTypes: [],
            sizeRange: { from: null, to: null },
            roomsRange: { from: null, to: null },
            bathroomsRange: { from: null, to: null },
            energyClasses: [],
            employmentTypes: [],
            salaryRange: { from: null, to: null },
            applicationDeadline: null
        };

        // Store event listeners for cleanup
        const eventListeners = new Set();

        // Function to safely add event listeners
        const addSafeEventListener = (element, event, handler) => {
            element.addEventListener(event, handler);
            eventListeners.add({ element, event, handler });
        };

        // Cleanup function
        function cleanup() {
            // Remove all stored event listeners
            eventListeners.forEach(({ element, event, handler }) => {
                element.removeEventListener(event, handler);
            });
            eventListeners.clear();

            // Cleanup lazy loader
            if (window.lazyLoader && window.lazyLoader.observer) {
                window.lazyLoader.observer.disconnect();
            }

            // Cleanup skeleton loader
            if (window.skeletonLoader) {
                window.skeletonLoader = null;
            }

            // Cleanup toast container
            const toastContainer = document.getElementById('toast-container');
            if (toastContainer) {
                toastContainer.innerHTML = '';
            }
        }

        // Add cleanup on page unload
        window.addEventListener('beforeunload', cleanup);

        // Update existing event listeners to use safe version
        const backToTopButton = document.getElementById('backToTop');
        if (backToTopButton) {
            const handleScroll = () => {
                if (window.scrollY > 300) {
                    backToTopButton.classList.add('visible');
                } else {
                    backToTopButton.classList.remove('visible');
                }
            };
            addSafeEventListener(window, 'scroll', handleScroll);
            addSafeEventListener(backToTopButton, 'click', () => {
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });
        }

        function showLoading() {
            document.getElementById('loadingOverlay').style.display = 'flex';
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        function displayProducts(products, loadMore = false) {
            const container = document.getElementById('productsContainer');
            if (!loadMore) {
                container.innerHTML = '';
            }

            if (!products || products.length === 0) {
                if (!loadMore) {
                    container.innerHTML = '<p class="no-products">No products found</p>';
                }
                return;
            }

            products.forEach(product => {
                const productElement = createProductElement(product);
                container.appendChild(productElement);
            });
        }

        function createProductElement(product) {
            const isJob = product.category === 'Jobb';
            const isCar = product.category === 'Bil';
            const isProperty = product.category === 'Eiendom';

            const div = document.createElement('div');
            div.className = 'product';
            div.setAttribute('role', 'article');
            div.setAttribute('aria-label', isJob ? product.JobTitle : 
                isCar ? `${product.brand_name} ${product.model_name}` : 
                product.ProductName);
            div.setAttribute('tabindex', '0');

            // Handle images
            const images = product.Images ? product.Images.split(',') : [];
            const firstImage = images.length > 0 ? images[0].trim() : null;
            const imageUrl = firstImage ? `/uploads/${firstImage}` : '/images/default-product.png';

            div.innerHTML = `
                <img src="${imageUrl}" 
                     alt="${isJob ? product.JobTitle : 
                        isCar ? `${product.brand_name} ${product.model_name}` : 
                        product.ProductName}" 
                     class="product-image" 
                     onerror="this.src='/images/default-product.png'"
                     loading="lazy"
                     aria-hidden="true">
                <div>
                    <h3>
                        ${isJob ? product.JobTitle || 'No title' : 
                        isCar ? 
                            `${product.brand_name || 'Unknown brand'} ${product.model_name || ''}`.trim() : 
                            product.ProductName || 'Unnamed product'}
                        ${product.Sold ? `<span class="sold-label" data-i18n="product_details.sold">(Sold)</span>` : ''}
                        <button class="fas fa-heart favorite-icon" 
                                data-product-id="${product.ProductdID}"
                                aria-label="${product.isFavorited ? 'Remove from favorites' : 'Add to favorites'}"
                                aria-pressed="${product.isFavorited ? 'true' : 'false'}">
                        </button>
                    </h3>
                    ${isCar ? `<p class="custom-title">${product.ProductName}</p>` : ''}
                    ${isJob ? `
                        <p><strong data-i18n="form.company_name">Company:</strong> ${product.CompanyName || 'Not specified'}</p>
                        <p><strong data-i18n="form.employment_type">Employment Type:</strong> ${product.EmploymentType || 'Not specified'}</p>
                    ` : ''}
                    ${isCar ? `
                        <p><strong data-i18n="form.year">Year:</strong> ${product.Year || 'N/A'}</p>
                        <p><strong data-i18n="form.mileage">Mileage:</strong> ${product.Mileage ? `${product.Mileage} km` : 'N/A'}</p>
                        <p><strong data-i18n="form.fuel_type">Fuel Type:</strong> ${product.FuelType || 'Not specified'}</p>
                    ` : ''}
                    ${isProperty ? `
                        <p><strong data-i18n="form.price">Price:</strong> ${product.Price ? `$${product.Price.toLocaleString('en-US')}` : 'Contact for price'}</p>
                        <p><strong data-i18n="form.property_type">Type:</strong> ${product.PropertyType}</p>
                        <p><strong data-i18n="property.size">Size:</strong> ${product.SizeSqm} m²</p>
                    ` : ''}
                    <p><strong data-i18n="form.location">Location:</strong> ${ 
                        (product.cityName || product.Location || 'Not specified') + 
                        (product.country ? `, ${product.country}` : '')
                    }</p>
                    ${!isJob && !isCar && !isProperty ? `<p><strong data-i18n="form.price">Price:</strong> ${product.Price ? `${product.Price.toLocaleString('en-US')} $` : 'Contact for price'}</p>` : ''}
                </div>
            `;

            // Add keyboard navigation
            div.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    window.location.href = `/productDetails?productdID=${product.ProductdID}`;
                }
            });

            // Add click event for the entire product
            div.addEventListener('click', (e) => {
                if (!e.target.classList.contains('favorite-icon')) {
                    window.location.href = `/productDetails?productdID=${product.ProductdID}`;
                }
            });

            // Add click event for the favorite icon
            const favoriteIcon = div.querySelector('.favorite-icon');
            if (favoriteIcon) {
                favoriteIcon.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const productdID = e.target.getAttribute('data-product-id');
                    const isFavorited = e.target.classList.contains('favorited');

                    try {
                        const response = await fetch('/api/favorites', {
                            method: 'POST',
                            credentials: 'include',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({ productdID }),
                        });

                        if (response.ok) {
                            e.target.classList.toggle('favorited');
                            e.target.style.color = isFavorited ? '#ccc' : '#ff4757';
                            window.toast.show(
                                isFavorited ? 'Product removed from favorites' : 'Product added to favorites',
                                'success'
                            );
                        } else {
                            window.toast.show('Failed to update favorites', 'error');
                        }
                    } catch (error) {
                        window.toast.show('An error occurred', 'error');
                    }
                });
            }

            return div;
        }

        function fetchProducts(loadMore = false, cacheBuster = null) {
            if (isLoading || (!loadMore && !hasMore)) return;
            
            showLoading();
            isLoading = true;

            if (!loadMore) {
                showSkeletonLoading();
            }

            // Calculate the page and offset
            const newPage = loadMore ? currentPage + 1 : 1;
            const offset = (newPage - 1) * limit;

            const urlParams = new URLSearchParams(window.location.search);
            const category = urlParams.get('category') || 'default';


            // Build API URL with current filters
            let apiUrl = `/api/products?category=${category}&limit=${limit}&offset=${offset}`;
            if (cacheBuster) {
                apiUrl += `&_=${cacheBuster}`;
            }
            if (currentFilters.subCategory) apiUrl += `&subCategory=${currentFilters.subCategory}`;
            if (currentFilters.priceOrder) apiUrl += `&sortPrice=${currentFilters.priceOrder}`;
            if (currentFilters.dateOrder) apiUrl += `&sortDate=${currentFilters.dateOrder}`;
            if (currentFilters.selectedCarBrands.length) apiUrl += `&carBrand=${currentFilters.selectedCarBrands.join(',')}`;
            if (currentFilters.selectedCountries.length) {
              apiUrl += `&countries=${encodeURIComponent(currentFilters.selectedCountries.join(','))}`;
            }
            if (currentFilters.selectedCities.length) {
              apiUrl += `&cities=${encodeURIComponent(currentFilters.selectedCities.join(','))}`;
            }

            // Add car specific filters
            if (category === 'Bil') {
                const yearConfig = sliderConfigs['year-slider'];
                // Ensure comparison uses numbers and checks for null
                if (currentFilters.yearRange.from !== null && Number(currentFilters.yearRange.from) !== yearConfig.start[0]) {
                    apiUrl += `&yearFrom=${currentFilters.yearRange.from}`;
                }
                if (currentFilters.yearRange.to !== null && Number(currentFilters.yearRange.to) !== yearConfig.start[1]) {
                    apiUrl += `&yearTo=${currentFilters.yearRange.to}`;
                }
                const mileageConfig = sliderConfigs['mileage-slider'];
                 // Ensure comparison uses numbers and checks for null
                if (currentFilters.mileageRange.from !== null && Number(currentFilters.mileageRange.from) !== mileageConfig.start[0]) {
                    apiUrl += `&mileageFrom=${currentFilters.mileageRange.from}`;
                }
                if (currentFilters.mileageRange.to !== null && Number(currentFilters.mileageRange.to) !== mileageConfig.start[1]) {
                    apiUrl += `&mileageTo=${currentFilters.mileageRange.to}`;
                }
                if (currentFilters.fuelTypes.length) {
                    apiUrl += `&fuelTypes=${currentFilters.fuelTypes.join(',')}`;
                }
                if (currentFilters.transmissionTypes.length) {
                    apiUrl += `&transmissionTypes=${currentFilters.transmissionTypes.join(',')}`;
                }
            }

            // Add property specific filters
            if (category === 'Eiendom') {
                if (currentFilters.propertyTypes.length) {
                    apiUrl += `&propertyType=${encodeURIComponent(currentFilters.propertyTypes.join(','))}`;
                }
                const sizeConfig = sliderConfigs['size-slider'];
                 // Ensure comparison uses numbers and checks for null
                if (currentFilters.sizeRange.from !== null && Number(currentFilters.sizeRange.from) !== sizeConfig.start[0]) {
                    apiUrl += `&sizeSqmFrom=${encodeURIComponent(currentFilters.sizeRange.from)}`;
                }
                if (currentFilters.sizeRange.to !== null && Number(currentFilters.sizeRange.to) !== sizeConfig.start[1]) {
                    apiUrl += `&sizeSqmTo=${encodeURIComponent(currentFilters.sizeRange.to)}`;
                }
                const roomsConfig = sliderConfigs['rooms-slider'];
                 // Ensure comparison uses numbers and checks for null
                if (currentFilters.roomsRange.from !== null && Number(currentFilters.roomsRange.from) !== roomsConfig.start[0]) {
                    apiUrl += `&numRoomsFrom=${encodeURIComponent(currentFilters.roomsRange.from)}`;
                }
                if (currentFilters.roomsRange.to !== null && Number(currentFilters.roomsRange.to) !== roomsConfig.start[1]) {
                    apiUrl += `&numRoomsTo=${encodeURIComponent(currentFilters.roomsRange.to)}`;
                }
                const bathroomsConfig = sliderConfigs['bathrooms-slider'];
                 // Ensure comparison uses numbers and checks for null
                if (currentFilters.bathroomsRange.from !== null && Number(currentFilters.bathroomsRange.from) !== bathroomsConfig.start[0]) {
                    apiUrl += `&numBathroomsFrom=${encodeURIComponent(currentFilters.bathroomsRange.from)}`;
                }
                if (currentFilters.bathroomsRange.to !== null && Number(currentFilters.bathroomsRange.to) !== bathroomsConfig.start[1]) {
                    apiUrl += `&numBathroomsTo=${encodeURIComponent(currentFilters.bathroomsRange.to)}`;
                }
                if (currentFilters.energyClasses.length) {
                    apiUrl += `&energyClass=${encodeURIComponent(currentFilters.energyClasses.join(','))}`;
                }
            }

            // Add work specific filters
            if (category === 'Jobb') {
                if (currentFilters.employmentTypes.length) {
                    apiUrl += `&employmentTypes=${currentFilters.employmentTypes.join(',')}`;
                }
                if (currentFilters.salaryRange.from) {
                    apiUrl += `&salaryFrom=${currentFilters.salaryRange.from}`;
                }
                if (currentFilters.salaryRange.to) {
                    apiUrl += `&salaryTo=${currentFilters.salaryRange.to}`;
                }
                if (currentFilters.applicationDeadline) {
                    apiUrl += `&deadline=${currentFilters.applicationDeadline}`;
                }
            }

            // Show loading state
            const container = document.getElementById('productsContainer');
            const loadButton = document.getElementById('loadMoreButton');
            if (!loadMore) container.innerHTML = '<p>Loading products...</p>';
            if (loadButton) {
                loadButton.disabled = true;
                loadButton.textContent = 'Loading...';
            }

            fetch(apiUrl)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                     hasMore = data.products.length >= limit;
                     displayProducts(data.products, loadMore); // Products are displayed here

                     // *** ADD FAVORITE CHECK HERE ***
                     initializeFavorites(); // Check favorite status after products are in the DOM

                     // Reposition the load more button to the bottom of the container
                     const loadButton = document.getElementById('loadMoreButton');
                     if (loadButton) {
                         const buttonWrapper = loadButton.parentElement;
                         document.getElementById('productsContainer').appendChild(buttonWrapper);
                     }

                     // Update currentPage after successful fetch
                    currentPage = newPage;
                    isLoading = false;

                    // Initialize lazy loading for new images
                    if (window.lazyLoader) window.lazyLoader.observe();

                    // Update load more button visibility and state
                    if (document.getElementById('loadMoreButton')) {
                     document.getElementById('loadMoreButton').style.display = hasMore ? 'block' : 'none';
                     document.getElementById('loadMoreButton').disabled = false;
                     document.getElementById('loadMoreButton').textContent = 'Load More';
                 } else {
                     addLoadMoreButton();
                 }
            })
                .catch(error => {
                    isLoading = false;
                    const container = document.getElementById('productsContainer');
                    container.innerHTML = `
                        <div class="error-message">
                            <p>Error loading products. Please try again.</p>
                            <button onclick="fetchProducts()" class="retry-button">Retry</button>
                        </div>
                    `;
                    window.toast.show('Error loading products. Please try again.', 'error');
                })
                .finally(() => {
                    hideLoading();
                });
        }



    // --- Slider Configuration ---
const sliderConfigs = {
    'year-slider': { range: { min: 1980, max: new Date().getFullYear() }, start: [1980, new Date().getFullYear()], step: 1, inputs: ['yearFrom', 'yearTo'], format: { to: v => Math.round(v), from: v => Math.round(v) } },
    'mileage-slider': { range: { min: 0, max: 500000 }, start: [0, 500000], step: 1000, inputs: ['mileageFrom', 'mileageTo'], format: { to: v => Math.round(v), from: v => Math.round(v) } },
    'size-slider': { range: { min: 10, max: 1000 }, start: [10, 1000], step: 10, inputs: ['sizeSqmFrom', 'sizeSqmTo'], format: { to: v => Math.round(v), from: v => Math.round(v) } },
    'rooms-slider': { range: { min: 1, max: 10 }, start: [1, 10], step: 1, inputs: ['numRoomsFrom', 'numRoomsTo'], format: { to: v => Math.round(v), from: v => Math.round(v) } },
    'bathrooms-slider': { range: { min: 1, max: 5 }, start: [1, 5], step: 1, inputs: ['numBathroomsFrom', 'numBathroomsTo'], format: { to: v => Math.round(v), from: v => Math.round(v) } }
    // Add more sliders here if needed
};

// --- Initialize Sliders Function ---
function initializeSliders() {
    Object.keys(sliderConfigs).forEach(sliderId => {
        const sliderElement = document.getElementById(sliderId);
        const config = sliderConfigs[sliderId];
        const minValDisplay = document.getElementById(`${sliderId}-val-min`);
        const maxValDisplay = document.getElementById(`${sliderId}-val-max`);
        const inputMin = document.getElementById(config.inputs[0]);
        const inputMax = document.getElementById(config.inputs[1]);

        if (sliderElement && inputMin && inputMax) {
            noUiSlider.create(sliderElement, {
                start: config.start,
                connect: true, // Fills the range between handles
                step: config.step,
                range: config.range,
                format: config.format, // Use formatting for whole numbers
                behaviour: 'tap-drag',
                tooltips: false // We'll use separate display elements
            });

            // Update display and hidden inputs when slider changes
            sliderElement.noUiSlider.on('update', (values) => {
                const [minVal, maxVal] = values;
                if (minValDisplay) minValDisplay.textContent = minVal;
                if (maxValDisplay) maxValDisplay.textContent = maxVal;
                inputMin.value = minVal; // Update hidden input
                inputMax.value = maxVal; // Update hidden input
            });

             // Trigger applyFilters ONLY when the user finishes sliding ('change' event)
             sliderElement.noUiSlider.on('change', () => {
                 // Update currentFilters state immediately on change for display purposes
                 updateCurrentFiltersFromUI();
                 // Debounce the actual API call
                 debouncedApplyFilters();
             });

             // Set initial display values
             const initialValues = sliderElement.noUiSlider.get();
             if (minValDisplay) minValDisplay.textContent = initialValues[0];
             if (maxValDisplay) maxValDisplay.textContent = initialValues[1];
        }
    });
}

        function resetFilters() {  
            // 1. Reset UI elements
            document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                checkbox.checked = false;
            });

            // 2. Hide city lists instead of clearing them
            document.querySelectorAll('.city-list').forEach(list => {
                list.style.display = 'none'; 
            });
            
            // Reset dropdowns
            document.getElementById('priceFilter').value = 'asc';
            document.getElementById('dateFilter').value = '';

            // Reset category-specific filters
            const urlParams = new URLSearchParams(window.location.search);
            const category = urlParams.get('category') || 'default';

            // Reset Torget filters
            if (category === 'Torget') {
                document.getElementById('subCategoryFilter').value = '';
            }

            // Reset Car filters
            if (category === 'Bil') {
                document.getElementById('yearFrom').value = '';
                document.getElementById('yearTo').value = '';
                document.getElementById('mileageFrom').value = '';
                document.getElementById('mileageTo').value = '';
                document.getElementById('fuelTypeFilter').selectedIndex = -1;
                document.getElementById('transmissionFilter').selectedIndex = -1;
            }

            // Reset Property filters
            if (category === 'Eiendom') {
                document.getElementById('propertyTypeFilter').selectedIndex = -1;
                document.getElementById('energyClassFilter').selectedIndex = -1;
            }

            // Reset Work filters
            if (category === 'Jobb') {
                document.getElementById('employmentTypeFilter').selectedIndex = -1;
                document.getElementById('salaryFrom').value = '';
                document.getElementById('salaryTo').value = '';
                document.getElementById('deadlineDate').value = '';
            }

             // Reset multi-selects
            ['fuelTypeFilter', 'transmissionFilter', 'propertyTypeFilter', 'energyClassFilter', 'employmentTypeFilter'].forEach(id => {
                const selectElement = document.getElementById(id);
                if (selectElement) {
                     Array.from(selectElement.options).forEach(option => option.selected = false);
                }
            });
             // Reset date input
            const deadlineDate = document.getElementById('deadlineDate');
            if (deadlineDate) deadlineDate.value = '';


            // --- START: ADD THIS SECTION TO RESET SLIDERS ---
            Object.keys(sliderConfigs).forEach(sliderId => {
                const sliderElement = document.getElementById(sliderId);
                if (sliderElement && sliderElement.noUiSlider) { // Check if slider exists and is initialized
                    // Reset the slider to its initial start values
                    sliderElement.noUiSlider.set(sliderConfigs[sliderId].start);
                    // Manually update hidden inputs immediately after reset
                    const config = sliderConfigs[sliderId];
                    const inputMin = document.getElementById(config.inputs[0]);
                    const inputMax = document.getElementById(config.inputs[1]);
                    if (inputMin) inputMin.value = sliderConfigs[sliderId].start[0];
                    if (inputMax) inputMax.value = sliderConfigs[sliderId].start[1];
                }
            });

            // 3. Reset internal state
            currentFilters = {
                priceOrder: document.getElementById('priceFilter').value, // Get the reset value
                dateOrder: '',
                subCategory: '',
                selectedCountries: [],
                selectedCarBrands: [],
                selectedCities: [],
                // Reset ranges in state using the default slider values
                yearRange: { from: sliderConfigs['year-slider'].start[0], to: sliderConfigs['year-slider'].start[1] },
                mileageRange: { from: sliderConfigs['mileage-slider'].start[0], to: sliderConfigs['mileage-slider'].start[1] },
                fuelTypes: [],
                transmissionTypes: [],
                propertyTypes: [],
                sizeRange: { from: sliderConfigs['size-slider'].start[0], to: sliderConfigs['size-slider'].start[1] },
                roomsRange: { from: sliderConfigs['rooms-slider'].start[0], to: sliderConfigs['rooms-slider'].start[1] },
                bathroomsRange: { from: sliderConfigs['bathrooms-slider'].start[0], to: sliderConfigs['bathrooms-slider'].start[1] },
                energyClasses: [],
                employmentTypes: [],
                salaryRange: { from: null, to: null }, // Assuming no salary slider yet
                applicationDeadline: null
            };

            // 4. Reset pagination
            currentPage = 1;
            hasMore = true;
            isLoading = false; 

            // 5. Clear container and force fresh load
            const container = document.getElementById('productsContainer');
            container.innerHTML = '<p>Loading products...</p>';
            showSkeletonLoading(); // Show skeleton immediately

            // --- Update Active Filters Display ---
             updateActiveFiltersDisplay(); // Update tags to show none are active
            
            // 6. Fetch with cache busting
            fetchProducts(false, Date.now());
        }

        window.resetFilters = resetFilters;
        window.fetchProducts = fetchProducts;

        function addLoadMoreButton() {
            const existingButton = document.getElementById('loadMoreButton');
            if (existingButton) return;

            const button = document.createElement('button');
            button.id = 'loadMoreButton';
            button.className = 'load-more-btn';
            button.textContent = 'Load More';
            button.style.display = hasMore ? 'block' : 'none';
             button.addEventListener('click', () => {
                fetchProducts(true);
            });
            
            const container = document.getElementById('productsContainer');
            const buttonWrapper = document.createElement('div');
            buttonWrapper.style.textAlign = 'center';
            buttonWrapper.style.width = '100%';
            buttonWrapper.appendChild(button);
            container.appendChild(buttonWrapper);
        }

        function applyFilters() {
            clearTimeout(filterTimeout);
            filterTimeout = setTimeout(() => {
                // --- Gather Filter Values ---
                updateCurrentFiltersFromUI(); // Use helper function

                 // Reset pagination for new filter set
                currentPage = 1;
                hasMore = true;

                // Clear container and fetch
                document.getElementById('productsContainer').innerHTML = ''; // Clear only products
                fetchProducts(); // Call your existing fetch function

                 // --- Update Active Filters Display ---
                updateActiveFiltersDisplay(); // Render the active filter tags

                // Get values from car filters
                const yearFrom = document.getElementById('yearFrom')?.value;
                const yearTo = document.getElementById('yearTo')?.value;
                const mileageFrom = document.getElementById('mileageFrom')?.value;
                const mileageTo = document.getElementById('mileageTo')?.value;
                const fuelTypeSelect = document.getElementById('fuelTypeFilter');
                const transmissionSelect = document.getElementById('transmissionFilter');

                // Get values from property filters
                const propertyTypeSelect = document.getElementById('propertyTypeFilter');
                const sizeFrom = document.getElementById('sizeFrom')?.value;
                const sizeTo = document.getElementById('sizeTo')?.value;
                const roomsFrom = document.getElementById('roomsFrom')?.value;
                const roomsTo = document.getElementById('roomsTo')?.value;
                const bathroomsFrom = document.getElementById('bathroomsFrom')?.value;
                const bathroomsTo = document.getElementById('bathroomsTo')?.value;
                const energyClassSelect = document.getElementById('energyClassFilter');

                // Get values from work filters
                const employmentTypeSelect = document.getElementById('employmentTypeFilter');
                const salaryFrom = document.getElementById('salaryFrom')?.value;
                const salaryTo = document.getElementById('salaryTo')?.value;
                const deadlineDate = document.getElementById('deadlineDate')?.value;

                currentFilters = {
                    priceOrder: document.getElementById('priceFilter').value,
                    dateOrder: document.getElementById('dateFilter').value,
                    subCategory: document.getElementById('subCategoryFilter')?.value || '',
                    selectedCountries: Array.from(
                        document.querySelectorAll('#mainSidePanel .country-list > li > div > input[type="checkbox"]:checked')
                    ).map(checkbox => checkbox.value),
                    selectedCities: Array.from(
                        document.querySelectorAll('#mainSidePanel .city-list input[type="checkbox"]:checked')
                    ).map(checkbox => checkbox.value),
                    selectedCarBrands: Array.from(
                        document.querySelectorAll('.car-brand-list input[type="checkbox"]:checked')
                    ).map(checkbox => checkbox.value),
                    yearRange: {
                        from: yearFrom || null,
                        to: yearTo || null
                    },
                    mileageRange: {
                        from: mileageFrom || null,
                        to: mileageTo || null
                    },
                    fuelTypes: Array.from(fuelTypeSelect?.selectedOptions || []).map(option => option.value),
                    transmissionTypes: Array.from(transmissionSelect?.selectedOptions || []).map(option => option.value),
                    propertyTypes: Array.from(propertyTypeSelect?.selectedOptions || []).map(option => option.value),
                    sizeRange: {
                        from: sizeFrom || null,
                        to: sizeTo || null
                    },
                    roomsRange: {
                        from: roomsFrom || null,
                        to: roomsTo || null
                    },
                    bathroomsRange: {
                        from: bathroomsFrom || null,
                        to: bathroomsTo || null
                    },
                    energyClasses: Array.from(energyClassSelect?.selectedOptions || []).map(option => option.value),
                    employmentTypes: Array.from(employmentTypeSelect?.selectedOptions || []).map(option => option.value),
                    salaryRange: {
                        from: salaryFrom || null,
                        to: salaryTo || null
                    },
                    applicationDeadline: deadlineDate || null
                };
                // Force reset pagination
                currentPage = 1;
                hasMore = true;
                document.getElementById('productsContainer').innerHTML = '<p>Loading products...</p>';
                fetchProducts();
            }, DEBOUNCE_DELAY);
        }

        // Define debouncedApplyFilters ONCE, AFTER debounce and applyFilters
        const debouncedApplyFilters = debounce(applyFilters, 300); // Or your delay

        // Add event listeners to all filter inputs
        const filterInputs = document.querySelectorAll('input[type="number"], input[type="date"], select');
        filterInputs.forEach(input => {
            input.addEventListener('input', debouncedApplyFilters);
            input.addEventListener('change', debouncedApplyFilters);
        });

        let filterTimeout;
        const DEBOUNCE_DELAY = 300; // ms

        // --- NEW: Helper to Update currentFilters Object from UI ---
function updateCurrentFiltersFromUI() {
    const urlParams = new URLSearchParams(window.location.search);
    const category = urlParams.get('category') || 'default';

    currentFilters = {
        priceOrder: document.getElementById('priceFilter')?.value || '',
        dateOrder: document.getElementById('dateFilter')?.value || '',
        subCategory: category === 'Torget' ? document.getElementById('subCategoryFilter')?.value || '' : '',
        
        // CORRECTED SELECTOR: Removed the incorrect '> div >' part
        selectedCountries: Array.from(
            document.querySelectorAll('#mainSidePanel .country-list > li > input[type="checkbox"]:checked')
        ).map(cb => cb.value),
        
        selectedCities: Array.from(document.querySelectorAll('#mainSidePanel .city-list input[type="checkbox"]:checked')).map(cb => cb.value),

        // CORRECTED SELECTOR: Also fixed it here for car brands for consistency
        selectedCarBrands: category === 'Bil' ? Array.from(document.querySelectorAll('#mainSidePanel .car-brand-list li > input[type="checkbox"]:checked')).map(cb => cb.value) : [],
        
        yearRange: { from: document.getElementById('yearFrom')?.value || null, to: document.getElementById('yearTo')?.value || null },
        mileageRange: { from: document.getElementById('mileageFrom')?.value || null, to: document.getElementById('mileageTo')?.value || null },
        fuelTypes: category === 'Bil' ? Array.from(document.getElementById('fuelTypeFilter')?.selectedOptions || []).map(opt => opt.value) : [],
        transmissionTypes: category === 'Bil' ? Array.from(document.getElementById('transmissionFilter')?.selectedOptions || []).map(opt => opt.value) : [],
        propertyTypes: category === 'Eiendom' ? Array.from(document.getElementById('propertyTypeFilter')?.selectedOptions || []).map(opt => opt.value) : [],
        sizeRange: { from: document.getElementById('sizeSqmFrom')?.value || null, to: document.getElementById('sizeSqmTo')?.value || null },
        roomsRange: { from: document.getElementById('numRoomsFrom')?.value || null, to: document.getElementById('numRoomsTo')?.value || null },
        bathroomsRange: { from: document.getElementById('numBathroomsFrom')?.value || null, to: document.getElementById('numBathroomsTo')?.value || null },
        energyClasses: category === 'Eiendom' ? Array.from(document.getElementById('energyClassFilter')?.selectedOptions || []).map(opt => opt.value) : [],
        employmentTypes: category === 'Jobb' ? Array.from(document.getElementById('employmentTypeFilter')?.selectedOptions || []).map(opt => opt.value) : [],
        salaryRange: { from: document.getElementById('salaryFrom')?.value || null, to: document.getElementById('salaryTo')?.value || null },
        applicationDeadline: category === 'Jobb' ? document.getElementById('deadlineDate')?.value || null : null
    };

    Object.keys(currentFilters).forEach(key => {
        if (typeof currentFilters[key] === 'object' && currentFilters[key] !== null && !Array.isArray(currentFilters[key])) {
            if (currentFilters[key].from === null || currentFilters[key].from === '') delete currentFilters[key].from;
            if (currentFilters[key].to === null || currentFilters[key].to === '') delete currentFilters[key].to;
        }
    });
}


// --- NEW: Function to Update Active Filters Display ---
// --- NEW: Function to Update Active Filters Display ---
function updateActiveFiltersDisplay() {
    const displayContainer = document.getElementById('activeFiltersDisplay');
    if (!displayContainer) return;
    displayContainer.innerHTML = '';

    let hasActiveFilters = false;

    const urlParams = new URLSearchParams(window.location.search);
    const currentCategory = urlParams.get('category') || 'default';

    const subCategoryTranslations = { 'Klær': 'Clothes', 'Elektronikk': 'Electronics', 'Hvitvarer': 'White Goods', 'Møbler': 'Furniture', 'Annet': 'Else' };

    const addFilterTag = (label, value, removeCallback) => {
        hasActiveFilters = true;
        const tag = document.createElement('span');
        tag.className = 'active-filter-tag';
        tag.innerHTML = `${label}: <strong>${value}</strong> <button class="remove-filter-btn" aria-label="Remove ${label} filter">×</button>`;
        tag.querySelector('.remove-filter-btn').addEventListener('click', removeCallback);
        displayContainer.appendChild(tag);
    };

    if (currentFilters.priceOrder) {
        const priceText = currentFilters.priceOrder === 'asc' ? 'Lowest First' : 'Highest First';
        addFilterTag('Sort Price', priceText, () => {
            document.getElementById('priceFilter').value = '';
            applyFilters();
        });
    }

    if (currentFilters.dateOrder) {
        const dateText = currentFilters.dateOrder === 'asc' ? 'Oldest First' : 'Newest First';
        addFilterTag('Sort Date', dateText, () => {
            document.getElementById('dateFilter').value = '';
            applyFilters();
        });
    }

    if (currentCategory === 'Torget' && currentFilters.subCategory) {
        const displayValue = subCategoryTranslations[currentFilters.subCategory] || currentFilters.subCategory;
        addFilterTag('Subcategory', displayValue, () => {
            document.getElementById('subCategoryFilter').value = '';
            applyFilters();
        });
    }

    // --- START: MODIFIED COUNTRY/CITY LOGIC ---

    // Create a map to hold the final location tags to be displayed
    const locationTags = new Map();

    // First, add all selected countries to the map as the default tag
    currentFilters.selectedCountries.forEach(countryValue => {
        const countryCheckbox = document.getElementById(countryValue);
        const countryLabel = countryCheckbox ? countryCheckbox.nextElementSibling.textContent : countryValue;
        locationTags.set(countryValue, { label: countryLabel, type: 'country' });
    });

    // Now, go through selected cities. If a city is found, it OVERWRITES its parent country's tag.
    currentFilters.selectedCities.forEach(cityId => {
        const cityCheckbox = document.getElementById(`city_${cityId}`);
        const countryListItem = cityCheckbox?.closest('.country-list > li');
        if (countryListItem) {
            const parentCountryCheckbox = countryListItem.querySelector('input[type="checkbox"]');
            if (parentCountryCheckbox) {
                const countryValue = parentCountryCheckbox.value;
                const cityName = cityCheckbox.nextElementSibling.textContent;
                const fullLocation = `${cityName}, ${countryValue}`;
                // Overwrite the simple country tag with the more specific city tag
                locationTags.set(countryValue, { label: fullLocation, type: 'city', cityId: cityId });
            }
        }
    });

    // Finally, create the HTML tags from our processed map
    for (const [key, tagInfo] of locationTags.entries()) {
        addFilterTag('Location', tagInfo.label, () => {
            if (tagInfo.type === 'city') {
                const cityCheckbox = document.getElementById(`city_${tagInfo.cityId}`);
                if (cityCheckbox) cityCheckbox.checked = false;
            } else { // type is 'country'
                const countryCheckbox = document.getElementById(key);
                if (countryCheckbox) {
                    countryCheckbox.checked = false;
                    const cityList = document.getElementById(`${key}-cities`);
                    if (cityList) {
                        cityList.querySelectorAll('input[type="checkbox"]').forEach(c => c.checked = false);
                        cityList.style.display = 'none';
                    }
                }
            }
            applyFilters();
        });
    }
    // --- END: MODIFIED COUNTRY/CITY LOGIC ---


    // --- Category Specific Tags (No changes needed below this line) ---
    if (currentCategory === 'Bil') {
        currentFilters.selectedCarBrands.forEach(brandId => {
            const brandCheckbox = document.getElementById(`brand_${brandId}`);
            const brandName = brandCheckbox ? brandCheckbox.nextElementSibling.textContent : `Brand ${brandId}`;
            addFilterTag('Brand', brandName, () => {
                if(brandCheckbox) brandCheckbox.checked = false;
                applyFilters();
            });
        });
        if (currentFilters.yearRange.from !== sliderConfigs['year-slider'].start[0] || currentFilters.yearRange.to !== sliderConfigs['year-slider'].start[1]) {
            const label = `${currentFilters.yearRange.from || sliderConfigs['year-slider'].range.min} - ${currentFilters.yearRange.to || sliderConfigs['year-slider'].range.max}`;
            addFilterTag('Year', label, () => {
                document.getElementById('year-slider').noUiSlider.set(sliderConfigs['year-slider'].start);
                applyFilters();
            });
        }
        if (currentFilters.mileageRange.from !== sliderConfigs['mileage-slider'].start[0] || currentFilters.mileageRange.to !== sliderConfigs['mileage-slider'].start[1]) {
             const label = `${currentFilters.mileageRange.from || sliderConfigs['mileage-slider'].range.min} - ${currentFilters.mileageRange.to || sliderConfigs['mileage-slider'].range.max} km`;
            addFilterTag('Mileage', label, () => {
                document.getElementById('mileage-slider').noUiSlider.set(sliderConfigs['mileage-slider'].start);
                applyFilters();
            });
        }
        if (currentFilters.fuelTypes && currentFilters.fuelTypes.length > 0) {
            addFilterTag('Fuel Types', currentFilters.fuelTypes.join(', '), () => {
                const selectElement = document.getElementById('fuelTypeFilter');
                if (selectElement) Array.from(selectElement.options).forEach(option => option.selected = false);
                applyFilters();
            });
        }
        if (currentFilters.transmissionTypes && currentFilters.transmissionTypes.length > 0) {
            addFilterTag('Transmission', currentFilters.transmissionTypes.join(', '), () => {
                const selectElement = document.getElementById('transmissionFilter');
                if (selectElement) Array.from(selectElement.options).forEach(option => option.selected = false);
                applyFilters();
            });
        }
    } 

    if (currentCategory === 'Eiendom') {
        if (currentFilters.propertyTypes && currentFilters.propertyTypes.length > 0) {
             addFilterTag('Property Types', currentFilters.propertyTypes.join(', '), () => {
                 const selectElement = document.getElementById('propertyTypeFilter');
                 if (selectElement) Array.from(selectElement.options).forEach(option => option.selected = false);
                 applyFilters();
             });
         }
        if (currentFilters.sizeRange.from !== sliderConfigs['size-slider'].start[0] || currentFilters.sizeRange.to !== sliderConfigs['size-slider'].start[1]) {
            const label = `${currentFilters.sizeRange.from || sliderConfigs['size-slider'].range.min} - ${currentFilters.sizeRange.to || sliderConfigs['size-slider'].range.max} m²`;
            addFilterTag('Size', label, () => {
                document.getElementById('size-slider').noUiSlider.set(sliderConfigs['size-slider'].start);
                applyFilters();
            });
        }
        if (currentFilters.roomsRange.from !== sliderConfigs['rooms-slider'].start[0] || currentFilters.roomsRange.to !== sliderConfigs['rooms-slider'].start[1]) {
             const label = `${currentFilters.roomsRange.from || sliderConfigs['rooms-slider'].range.min} - ${currentFilters.roomsRange.to || sliderConfigs['rooms-slider'].range.max}`;
            addFilterTag('Rooms', label, () => {
                document.getElementById('rooms-slider').noUiSlider.set(sliderConfigs['rooms-slider'].start);
                applyFilters();
            });
        }
        if (currentFilters.bathroomsRange.from !== sliderConfigs['bathrooms-slider'].start[0] || currentFilters.bathroomsRange.to !== sliderConfigs['bathrooms-slider'].start[1]) {
             const label = `${currentFilters.bathroomsRange.from || sliderConfigs['bathrooms-slider'].range.min} - ${currentFilters.bathroomsRange.to || sliderConfigs['bathrooms-slider'].range.max}`;
            addFilterTag('Bathrooms', label, () => {
                document.getElementById('bathrooms-slider').noUiSlider.set(sliderConfigs['bathrooms-slider'].start);
                applyFilters();
            });
        }
        if (currentFilters.energyClasses && currentFilters.energyClasses.length > 0) {
             addFilterTag('Energy Classes', currentFilters.energyClasses.join(', '), () => {
                 const selectElement = document.getElementById('energyClassFilter');
                 if (selectElement) Array.from(selectElement.options).forEach(option => option.selected = false);
                 applyFilters();
             });
         }
    } 

     if (currentCategory === 'Jobb') {
        if (currentFilters.employmentTypes && currentFilters.employmentTypes.length > 0) {
             addFilterTag('Employment Types', currentFilters.employmentTypes.join(', '), () => {
                 const selectElement = document.getElementById('employmentTypeFilter');
                 if (selectElement) Array.from(selectElement.options).forEach(option => option.selected = false);
                 applyFilters();
             });
         }
     }

    displayContainer.style.display = hasActiveFilters ? 'flex' : 'none';
}

// Ensure other event listeners also call applyFilters correctly
// (e.g., listeners for checkboxes, dropdowns)

// --- Make applyFilters globally accessible if needed by inline `onchange` ---
// It's generally better to attach listeners programmatically in JS,
// but if you keep onchange="", this makes it work.
window.applyFilters = applyFilters;

// --- Add event listeners to filters ---
function setupFilterListeners() {
    // Dropdowns (Price, Date, SubCategory)
    ['priceFilter', 'dateFilter', 'subCategoryFilter'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('change', applyFilters); // Use non-debounced for immediate select change
    });

    // Checkboxes (Countries, Cities, Brands) - These are added dynamically, attach in initialize functions
    // No need for separate listeners here if attached during creation

    // Sliders - Listener attached during initialization ('change' event uses debouncedApplyFilters)

    // Multi-Selects
    ['fuelTypeFilter', 'transmissionFilter', 'propertyTypeFilter', 'energyClassFilter', 'employmentTypeFilter'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('change', applyFilters); // Use non-debounced for immediate select change
    });

    // Range Input Fields (From/To for text inputs if any - not currently used with sliders)

    // Date Input
    const deadlineDate = document.getElementById('deadlineDate');
    if (deadlineDate) deadlineDate.addEventListener('change', applyFilters);
}

        document.getElementById('dateFilter').addEventListener('change', () => {
        document.getElementById('priceFilter').value = '';
        applyFilters();
    });
        document.getElementById('priceFilter').addEventListener('change', () => {
        document.getElementById('dateFilter').value = '';
        applyFilters();
    });

    function handleCategoryVisibility() {
         const urlParams = new URLSearchParams(window.location.search);
        const category = urlParams.get('category') || 'default';

        // --- Get references to filter UI elements ---
        const subcategoryContainer = document.getElementById('subcategoryFilterContainer'); // Top filter bar section
        const carBrandList = document.getElementById('carBrandList');           // Car brand checkbox list
        const carBrandLabel = document.getElementById('filterCar');              // Car brand <h3> heading
        const carSpecificFilters = document.getElementById('carSpecificFilters'); // DIV containing car sliders/selects
        const propertySpecificFilters = document.getElementById('propertySpecificFilters'); // DIV containing property sliders/selects
        const workSpecificFilters = document.getElementById('workSpecificFilters'); // DIV containing work selects/inputs
        const resetFiltersBtn = document.getElementById('resetFiltersBtn');

        // --- Hide ALL potentially category-specific elements initially ---
        if (subcategoryContainer) subcategoryContainer.style.display = 'none'; // Hide top subcat filter
        if (carBrandList) carBrandList.style.display = 'none';                 // Hide car brand list
        if (carBrandLabel) carBrandLabel.style.display = 'none';               // Hide car brand heading
        if (carSpecificFilters) carSpecificFilters.style.display = 'none';     // Hide car specific div
        if (propertySpecificFilters) propertySpecificFilters.style.display = 'none'; // Hide property specific div
        if (workSpecificFilters) workSpecificFilters.style.display = 'none';     // Hide work specific div
        // Add others if needed (e.g., boat, MC)

        let showResetButton = false; // Flag for the main reset button

        // --- Show elements based on the current category ---
        switch (category) {
            case 'Torget':
                if (subcategoryContainer) subcategoryContainer.style.display = 'block'; // Show top subcat filter
                showResetButton = true;
                break;
            case 'Bil':
                if (carBrandList) carBrandList.style.display = 'block';       // Show car brand list
                if (carBrandLabel) carBrandLabel.style.display = 'block';     // Show car brand heading
                if (carSpecificFilters) carSpecificFilters.style.display = 'block'; // Show car specific div
                showResetButton = true;
                break;
            case 'Eiendom':
                if (propertySpecificFilters) propertySpecificFilters.style.display = 'block'; // Show property specific div
                showResetButton = true;
                break;
            case 'Jobb':
                if (workSpecificFilters) workSpecificFilters.style.display = 'block'; // Show work specific div
                showResetButton = true;
                break;
             case 'Båt': // Example for Boat category
                 // if (boatSpecificFilters) boatSpecificFilters.style.display = 'block';
                 // showResetButton = true; // Decide if Boat needs reset
                 break;
            case 'MC': // Example for MC category
                 // if (mcSpecificFilters) mcSpecificFilters.style.display = 'block';
                 // showResetButton = true; // Decide if MC needs reset
                 break;
            default:
                // No specific filters for other categories or default view
                break;
        }

        // Show/hide the global reset button
        if (resetFiltersBtn) {
            resetFiltersBtn.style.display = showResetButton ? 'flex' : 'none';
        }
    }

        function initializeFilters() {
            // Add a flag to track if filters have been initialized
            if (window.filtersInitialized) {
                return;
            }
            window.filtersInitialized = true;


            // Price and Date filters
            document.getElementById('priceFilter').addEventListener('change', applyFilters);
            document.getElementById('dateFilter').addEventListener('change', applyFilters);
            
            // Subcategory filter
            const subCategoryFilter = document.getElementById('subCategoryFilter');
            if (subCategoryFilter) {
                subCategoryFilter.addEventListener('change', applyFilters);
            }

            // Add event listeners for work filters
            ['salaryFrom', 'salaryTo'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('change', applyFilters);
                    element.addEventListener('input', function() {
                        if (this.value.length > 10) {
                            this.value = this.value.slice(0, 10);
                        }
                    });
                }
            });

            const deadlineDate = document.getElementById('deadlineDate');
            if (deadlineDate) {
                deadlineDate.addEventListener('change', applyFilters);
                const today = new Date().toISOString().split('T')[0];
                deadlineDate.min = today;
            }

            // Add event listeners for all filter elements
            ['employmentTypeFilter', 'propertyTypeFilter', 'energyClassFilter', 'fuelTypeFilter', 'transmissionFilter'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('change', applyFilters);
                }
            });

            // Add event listeners for numeric inputs
            ['sizeFrom', 'sizeTo', 'roomsFrom', 'roomsTo', 'bathroomsFrom', 'bathroomsTo', 'yearFrom', 'yearTo', 'mileageFrom', 'mileageTo'].forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.addEventListener('input', applyFilters);
                    element.addEventListener('change', applyFilters);
                    element.addEventListener('input', function() {
                        if (this.value.length > 7) {
                            this.value = this.value.slice(0, 7);
                        }
                    });
                }
            });

        }

        // --- REMOVE THIS BLOCK ---
       /*
       const saveSearchBtn = document.getElementById('saveSearchBtn');
         if (saveSearchBtn) {
             saveSearchBtn.addEventListener('click', async () => {
                 // ... existing save logic ...
             });
         }
       */
       // --- END REMOVAL ---


        // --- ADD THIS DELEGATED LISTENER ---
        document.body.addEventListener('click', async (event) => {
            const saveButton = event.target.closest('.save-search-button'); // Check if click was on or inside the button
            if (!saveButton) {
                return; // Click wasn't on the save button
            }

            // --- Existing Save Search Logic START ---
            // (Copied from the original direct listener)
            try {
                const userRes = await fetch('/api/auth/current-user');
                const userData = await userRes.json();
                if (!userData || !userData.brukerId) {
                    window.toast.show('Please log in to save searches.', 'info');
                    return;
                }
            } catch (error) {
                window.toast.show('Could not verify login status.', 'error');
                return;
            }

            const searchName = prompt("Enter a name for this search:");
            if (!searchName || searchName.trim() === '') {
                window.toast.show('Search not saved (no name provided).', 'warning');
                return;
            }

            const urlParams = new URLSearchParams(window.location.search);
            const category = urlParams.get('category');

            if (!category) {
                window.toast.show('Cannot save search: Category not identified.', 'error');
                return;
            }

            const filtersToSave = {};

            // --- Add Common Filters (Reads from MAIN panel elements, assuming sync works) ---
            const selectedCountries = Array.from(
                document.querySelectorAll('#mainSidePanel .country-list > li > div > input[type="checkbox"]:checked') // Read from main panel
            ).map(cb => cb.value);
            if (selectedCountries.length > 0) filtersToSave.countries = selectedCountries;

            const selectedCities = Array.from(document.querySelectorAll('#mainSidePanel .city-list input[type="checkbox"]:checked')).map(cb => cb.value); // Read from main panel
            if (selectedCities.length > 0) filtersToSave.cities = selectedCities;

            // --- Add Category-Specific Filters (Reads from MAIN panel elements) ---
            switch (category) {
                case 'Torget':
                    const subCategory = document.getElementById('subCategoryFilter')?.value; // Read from main filter bar
                    if (subCategory) filtersToSave.subCategory = subCategory;
                    break;

                case 'Bil':
                    const selectedCarBrands = Array.from(document.querySelectorAll('#mainSidePanel .car-brand-list input[type="checkbox"]:checked')).map(cb => cb.value); // Read from main panel
                    if (selectedCarBrands.length > 0) filtersToSave.car_brands = selectedCarBrands;

                    const yearFrom = document.getElementById('yearFrom')?.value; // Read from main panel
                    const yearTo = document.getElementById('yearTo')?.value;     // Read from main panel
                    if (yearFrom || yearTo) filtersToSave.yearRange = { from: yearFrom || null, to: yearTo || null };

                    const mileageFrom = document.getElementById('mileageFrom')?.value; // Read from main panel
                    const mileageTo = document.getElementById('mileageTo')?.value;     // Read from main panel
                    if (mileageFrom || mileageTo) filtersToSave.mileageRange = { from: mileageFrom || null, to: mileageTo || null };

                    const fuelTypes = Array.from(document.getElementById('fuelTypeFilter')?.selectedOptions || []).map(opt => opt.value); // Read from main panel
                    if (fuelTypes.length > 0) filtersToSave.fuel_types = fuelTypes;

                    const transmissionTypes = Array.from(document.getElementById('transmissionFilter')?.selectedOptions || []).map(opt => opt.value); // Read from main panel
                    if (transmissionTypes.length > 0) filtersToSave.transmission_types = transmissionTypes;
                    break;

                case 'Eiendom':
                    const propertyTypes = Array.from(document.getElementById('propertyTypeFilter')?.selectedOptions || []).map(opt => opt.value); // Read from main panel
                    if (propertyTypes.length > 0) filtersToSave.property_types = propertyTypes;

                    const sizeSqmFrom = document.getElementById('sizeSqmFrom')?.value; // Read from main panel
                    const sizeSqmTo = document.getElementById('sizeSqmTo')?.value;     // Read from main panel
                    if (sizeSqmFrom || sizeSqmTo) filtersToSave.sizeRange = { from: sizeSqmFrom || null, to: sizeSqmTo || null };

                    const numRoomsFrom = document.getElementById('numRoomsFrom')?.value; // Read from main panel
                    const numRoomsTo = document.getElementById('numRoomsTo')?.value;     // Read from main panel
                    if (numRoomsFrom || numRoomsTo) filtersToSave.roomsRange = { from: numRoomsFrom || null, to: numRoomsTo || null };

                    const numBathroomsFrom = document.getElementById('numBathroomsFrom')?.value; // Read from main panel
                    const numBathroomsTo = document.getElementById('numBathroomsTo')?.value;     // Read from main panel
                    if (numBathroomsFrom || numBathroomsTo) filtersToSave.bathroomsRange = { from: numBathroomsFrom || null, to: numBathroomsTo || null };

                    const energyClasses = Array.from(document.getElementById('energyClassFilter')?.selectedOptions || []).map(opt => opt.value); // Read from main panel
                    if (energyClasses.length > 0) filtersToSave.energy_classes = energyClasses;
                    break;

                case 'Jobb':
                    const employmentTypes = Array.from(document.getElementById('employmentTypeFilter')?.selectedOptions || []).map(opt => opt.value); // Read from main panel
                    if (employmentTypes.length > 0) filtersToSave.employment_types = employmentTypes;

                    const salaryFrom = document.getElementById('salaryFrom')?.value; // Read from main panel
                    const salaryTo = document.getElementById('salaryTo')?.value;     // Read from main panel
                    if (salaryFrom || salaryTo) filtersToSave.salaryRange = { from: salaryFrom || null, to: salaryTo || null };

                    const applicationDeadline = document.getElementById('deadlineDate')?.value; // Read from main panel
                    if (applicationDeadline) filtersToSave.applicationDeadline = applicationDeadline;
                    break;
            }

            try {
                const response = await fetch('/api/saved-searches', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        search_name: searchName,
                        category: category,
                        filters: filtersToSave
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || 'Failed to save search.');
                }

                const result = await response.json();
                window.toast.show(`Search '${result.search_name}' saved successfully!`, 'success');

            } catch (error) {
                window.toast.show(`Error: ${error.message}`, 'error');
            }
            // --- Existing Save Search Logic END ---
        });
        // --- END ADDED LISTENER ---


function applyFiltersFromURL() {
    const urlParams = new URLSearchParams(window.location.search);

    let filtersApplied = false; // Flag to see if we actually changed anything

    // --- Helper Function to Update Multi-Select ---
    const updateMultiSelect = (selectId, values) => {
        const select = document.getElementById(selectId);
        if (select && values && values.length > 0) {
            Array.from(select.options).forEach(option => {
                option.selected = values.includes(option.value);
            });
            filtersApplied = true;
        }
    };

    // --- Helper Function to Update Checkboxes ---
    const updateCheckboxes = (selector, values) => {
        if (values && values.length > 0) {
            document.querySelectorAll(selector).forEach(checkbox => {
                if (values.includes(checkbox.value)) {
                    checkbox.checked = true;
                    // If it's a city checkbox, make sure its country list is expanded
                    const cityList = checkbox.closest('.city-list');
                    if (cityList && cityList.style.display !== 'block') {
                         const countryCheckbox = cityList.closest('li').querySelector('input[type="checkbox"]');
                         if (countryCheckbox) countryCheckbox.checked = true; // Ensure country is checked too
                         cityList.style.display = 'block';
                    }
                     filtersApplied = true;
                } else {
                    checkbox.checked = false;
                }
            });

        }
    };

     // --- Helper Function to Update Single Select ---
    const updateSingleSelect = (selectId, value) => {
         const select = document.getElementById(selectId);
         if (select && value) {
             select.value = value;
             if(select.value === value) filtersApplied = true; // Check if value was successfully set
         }
     };

     // --- Helper Function to Update Slider ---
     const updateSlider = (sliderId, fromValue, toValue) => {
          const sliderElement = document.getElementById(sliderId);
          const config = sliderConfigs[sliderId]; // Assumes sliderConfigs is accessible
          if (sliderElement && sliderElement.noUiSlider && config) {
              const currentVals = sliderElement.noUiSlider.get();
              const newFrom = fromValue !== null ? parseFloat(fromValue) : config.start[0];
              const newTo = toValue !== null ? parseFloat(toValue) : config.start[1];

              // Only update if values are different from default start AND valid within range
              if ((!isNaN(newFrom) && !isNaN(newTo)) &&
                  (newFrom !== config.start[0] || newTo !== config.start[1]) &&
                  (newFrom >= config.range.min && newTo <= config.range.max && newFrom <= newTo))
              {
                   sliderElement.noUiSlider.set([newFrom, newTo]);
                   // Update hidden inputs associated with the slider
                   document.getElementById(config.inputs[0]).value = newFrom;
                   document.getElementById(config.inputs[1]).value = newTo;
                   filtersApplied = true;
              }
          }
      };

    // --- Apply Filters based on URL Params ---

    // Sort Orders (update dropdowns)
    updateSingleSelect('priceFilter', urlParams.get('sortPrice'));
    updateSingleSelect('dateFilter', urlParams.get('sortDate'));

    // Common Filters
    updateCheckboxes('.country-list input[type="checkbox"]', urlParams.get('countries')?.split(','));
    updateCheckboxes('.city-list input[type="checkbox"]', urlParams.get('cities')?.split(','));

    // Category Specific Filters
    const category = urlParams.get('category');
    switch(category) {
        case 'Torget':
            updateSingleSelect('subCategoryFilter', urlParams.get('subCategory'));
            break;
        case 'Bil':
            updateCheckboxes('.car-brand-list input[type="checkbox"]', urlParams.get('carBrand')?.split(',')); // Use carBrand key
            updateSlider('year-slider', urlParams.get('yearFrom'), urlParams.get('yearTo'));
            updateSlider('mileage-slider', urlParams.get('mileageFrom'), urlParams.get('mileageTo'));
            updateMultiSelect('fuelTypeFilter', urlParams.get('fuelTypes')?.split(','));
            updateMultiSelect('transmissionFilter', urlParams.get('transmissionTypes')?.split(','));
            break;
        case 'Eiendom':
             updateMultiSelect('propertyTypeFilter', urlParams.get('propertyType')?.split(','));
             updateSlider('size-slider', urlParams.get('sizeSqmFrom'), urlParams.get('sizeSqmTo'));
             updateSlider('rooms-slider', urlParams.get('numRoomsFrom'), urlParams.get('numRoomsTo'));
             updateSlider('bathrooms-slider', urlParams.get('numBathroomsFrom'), urlParams.get('numBathroomsTo'));
             updateMultiSelect('energyClassFilter', urlParams.get('energyClass')?.split(','));
            break;
         case 'Jobb':
             updateMultiSelect('employmentTypeFilter', urlParams.get('employmentTypes')?.split(','));
             // Update salary range inputs (assuming no slider yet)
             const salaryFromInput = document.getElementById('salaryFrom');
             const salaryToInput = document.getElementById('salaryTo');
             if(salaryFromInput && urlParams.has('salaryFrom')) salaryFromInput.value = urlParams.get('salaryFrom');
             if(salaryToInput && urlParams.has('salaryTo')) salaryToInput.value = urlParams.get('salaryTo');
             // Update deadline input
             const deadlineInput = document.getElementById('deadlineDate');
             if(deadlineInput && urlParams.has('deadline')) deadlineInput.value = urlParams.get('deadline');
            break;
        // Add cases for Båt, MC if needed
    }

    return filtersApplied; // Return true if any UI element was changed
}
        async function initializeCountries() {
        const countryList = document.querySelector('.country-list');

        if (!countryList) {
            return Promise.reject("Country list container not found");
        }

        // --- Refined Check ---
        // Check specifically for a country checkbox structure, not just any li
        // Use a data attribute to mark initialization?
        const isAlreadyInitialized = countryList.dataset.initialized === 'true';
        const hasCountryCheckboxes = countryList.querySelector('li > div > input[type="checkbox"][id]:not([id^="city_"])'); // Look for a country ID, not a city ID

        if (isAlreadyInitialized || hasCountryCheckboxes) {
            // If it has checkboxes but isn't marked initialized, mark it now?
            if (hasCountryCheckboxes && !isAlreadyInitialized) {
                countryList.dataset.initialized = 'true';
            }
            return Promise.resolve(); // Already populated or marked
        }

        countryList.innerHTML = ''; // Clear any "Loading...", "Error..." messages FIRST

        return fetch('/api/utils/countries')
            .then(response => response.json())
            .then(countries => {
                  if (countries.length === 0) {
                     countryList.innerHTML = '<li>No countries available.</li>';
                     countryList.dataset.initialized = 'true'; // Mark as initialized even if empty
                     return;
                }

                // *** Mark as initialized AFTER successfully adding elements ***
                countryList.dataset.initialized = 'true';

                    countries.forEach(countryData => {
                        const countryItem = document.createElement('li');
                        // The input and label are now direct children of the <li>
                        countryItem.innerHTML = `
                            <input type="checkbox" id="${countryData.country}" value="${countryData.country}">
                            <label for="${countryData.country}">${countryData.country}</label>
                            <ul class="city-list" id="${countryData.country}-cities" style="display: none;"></ul>
                        `;
                        
                        const cityList = countryItem.querySelector('.city-list');
                        countryData.cities = countryData.cities || []; // Ensure it's an array
                        const cities = Array.isArray(countryData.cities) ? countryData.cities : [];
                        const cityIds = Array.isArray(countryData.city_ids) ? countryData.city_ids : [];

                        cities.forEach((cityName, index) => {
                            const cityId = cityIds[index] || `unknown_${index}`; // Handle missing IDs
                            cityList.innerHTML += `
                                <li>
                                    <input type="checkbox" id="city_${cityId}" value="${cityId}">
                                    <label for="city_${cityId}">${cityName}</label>
                                </li>
                            `;
                        });

                        /*
                        const countryCheckbox = countryItem.querySelector('input[type="checkbox"]');
                        countryCheckbox.addEventListener('change', function() {
                            const cityList = countryItem.querySelector('.city-list');
                            const cityCheckboxes = cityList.querySelectorAll('input[type="checkbox"]');
                            if (!this.checked) {
                                cityCheckboxes.forEach(cityCB => cityCB.checked = false);
                            }
                            cityList.style.display = this.checked ? 'block' : 'none';
                            applyFilters();
                        });
                        */

                        countryList.appendChild(countryItem);
                    });

                    /*document.querySelectorAll('.city-list input').forEach(cityCheckbox => {
                        cityCheckbox.addEventListener('change', applyFilters);
                    });
                    */
                })
                .catch(error => {
                countryList.innerHTML = `<li style="color: red;">Error: ${error.message}.</li>`;
                // Don't mark as initialized on error
                delete countryList.dataset.initialized;
                return Promise.reject(error);
                });
        }

         async function initializeCarBrands() {
          const container = document.getElementById('carBrandList'); // Assuming ID is correct
        // ... (check container exists) ...

        const isAlreadyInitialized = container.dataset.initialized === 'true';
        const hasBrandCheckboxes = container.querySelector('li > div > input[type="checkbox"][id^="brand_"]');

        if (isAlreadyInitialized || hasBrandCheckboxes) {
             if(hasBrandCheckboxes && !isAlreadyInitialized) container.dataset.initialized = 'true';
             return Promise.resolve();
        }

        container.innerHTML = ''; // Clear stale content

        return fetch('/api/utils/car-brands')
                .then(response => response.json())
                .then(brands => {
                    if (!brands || brands.length === 0) {
                        return;
                    }

                    brands.forEach(brand => {
                        const li = document.createElement('li');
                        li.innerHTML = `
                                <input type="checkbox" id="brand_${brand.brand_id}" value="${brand.brand_id}">
                                <label for="brand_${brand.brand_id}">${brand.brand_name}</label>
                            
                        `;
                        container.appendChild(li);

                        const checkbox = li.querySelector('input[type="checkbox"]');
                        checkbox.addEventListener('change', applyFilters);
                    });
                })
                .catch(error => {
                    container.innerHTML = '<p>Error loading car brands</p>';
                    return Promise.resolve();
                });
        }

        function initializeFavorites() {
            fetch('/api/favorites')
                .then(response => response.json())
                .then(favorites => {
                    document.querySelectorAll('.favorite-icon').forEach(icon => {
                        const productdID = icon.getAttribute('data-product-id');
                        const isFavorited = favorites.some(product => product.ProductdID === Number(productdID));
                        icon.classList.toggle('favorited', isFavorited);
                        icon.style.color = isFavorited ? '#ff4757' : '#ccc';
                    });
                })
                .catch(error => {});
        }

        function showSkeletonLoading() {
            const container = document.getElementById('productsContainer');
            container.innerHTML = '';
            for (let i = 0; i < 8; i++) {
                const skeleton = document.createElement('div');
                skeleton.className = 'product skeleton';
                skeleton.innerHTML = `
                    <div class="skeleton-image skeleton"></div>
                    <div>
                        <div class="skeleton-text skeleton-title skeleton"></div>
                        <div class="skeleton-text skeleton-price skeleton"></div>
                        <div class="skeleton-text skeleton-location skeleton"></div>
                    </div>
                `;
                container.appendChild(skeleton);
            }
        }

         window.addEventListener('load', async () => { // Use 'load' if images etc. affect layout, 'DOMContentLoaded' otherwise
          const countryList = document.querySelector('.country-list');
          const carBrandList = document.getElementById('carBrandList');
          if (countryList) delete countryList.dataset.initialized;
          if (carBrandList) delete carBrandList.dataset.initialized;
        try {
            // --- Synchronous Setup First ---
            handleCategoryVisibility(); // Determine which filters *should* be visible
            initializeSliders();        // Setup sliders (uses existing DOM elements)
            initializeFilters();       // Add basic listeners to static elements
            checkUnreadMessages();     // Any other sync setup

            // --- Wait for ASYNC UI elements to be created ---
            await Promise.all([
                initializeCountries(),
                initializeCarBrands()
                // Add other async initializations here if needed
            ]);

            // --- Now Apply Filters from URL (elements exist) ---
            const urlFiltersApplied = applyFiltersFromURL();
            // --- Update UI and Fetch Initial Data ---
            updateActiveFiltersDisplay(); // Show filter tags based on URL/UI state

            // Fetch products *after* ensuring URL filters are applied to the UI state
            // applyFilters() internally updates currentFilters and calls fetchProducts
            if (urlFiltersApplied) {
                 applyFilters(); // Trigger a filter application which includes fetching
             } else {
                 fetchProducts(); // Fetch default products if no URL filters were applied
             }

            // Setup remaining listeners (like save search button)
            const saveSearchBtn = document.getElementById('saveSearchBtn');
             if (saveSearchBtn) {
                // ... attach your save search listener here ...
                saveSearchBtn.addEventListener('click', async () => { /* ... your existing save logic ... */ });
             }
             
            // Initialize lazy loading last
            if (window.lazyLoader) {
                window.lazyLoader.observe();
            }

        } catch (error) {
            // Display a user-friendly error message on the page if appropriate
            const container = document.getElementById('productsContainer');
            if(container) container.innerHTML = "<p class='error-message'>An error occurred loading the page. Please try refreshing.</p>";
        }
    });

    // --- Off-Canvas Filter Drawer Logic ---
    (function() {
        const filterBtn = document.getElementById('offcanvasFilterBtn');
        const drawer = document.getElementById('offcanvasFilterDrawer');
        const overlay = document.getElementById('offcanvasFilterOverlay');
        const closeBtn = document.getElementById('offcanvasFilterClose');
        const mainSidePanel = document.getElementById('mainSidePanel');
        const offcanvasSidePanel = document.getElementById('offcanvasSidePanel');
        const topFilterContainer = document.querySelector('.filter-container-wrapper .filter-container'); // Get the top filter container

          // --- START: NEW DELEGATED EVENT LISTENER ---
    
    // This function will handle clicks from BOTH the main panel and the drawer
    function handleFilterChange(event) {
        const target = event.target;

        // Exit if the clicked element is not a checkbox inside a filter list
        if (target.type !== 'checkbox' || !target.closest('.country-list, .car-brand-list, .city-list')) {
            return;
        }

        // --- Logic for Country Checkbox Clicks ---
        const countryListItem = target.closest('.country-list > li');
        if (countryListItem && target.id === countryListItem.querySelector('input[type="checkbox"]')?.id) {
            
            // Find the city list associated with THIS checkbox
            const cityList = countryListItem.querySelector('.city-list');
            if (cityList) {
                cityList.style.display = target.checked ? 'block' : 'none';
                
                // If unchecking the country, also uncheck all its cities
                if (!target.checked) {
                    cityList.querySelectorAll('input[type="checkbox"]').forEach(cityCB => {
                        cityCB.checked = false;
                    });
                }
            }
        }
        
        // --- Sync state back to the other panel (if inside drawer) ---
        if (drawer.contains(target)) {
            const mainId = target.dataset.syncId || target.id.replace('-drawer', '');
            const mainElement = document.getElementById(mainId);
            if (mainElement) {
                mainElement.checked = target.checked;
            }
        }

        // Finally, apply the filters after any change
        applyFilters();
    }

    // Attach the single listener to both containers
    if (mainSidePanel) {
        mainSidePanel.addEventListener('change', handleFilterChange);
    }
    if (drawer) {
        drawer.addEventListener('change', handleFilterChange);
    }
    
    // --- END: NEW DELEGATED EVENT LISTENER ---

        // Always sync side-panel content AND top filters into drawer on open
        function syncSidePanelToDrawer() {
            if (!mainSidePanel || !offcanvasSidePanel || !topFilterContainer) return;
            // Only sync if drawer is intended for the current viewport
            if (window.innerWidth <= 900) { // Or your mobile breakpoint
                // Combine top filters and side panel content
                offcanvasSidePanel.innerHTML = topFilterContainer.outerHTML + mainSidePanel.innerHTML;

                // NEW: ensure drawer inputs/labels use unique IDs but can sync back to main panel
                // --- START: Modify querySelectorAll to include 'select[id]' ---
                offcanvasSidePanel.querySelectorAll('input[id], select[id]').forEach(element => {
                    element.dataset.syncId = element.id;       // remember original ID
                    element.id = element.id + '-drawer';       // give drawer element a unique ID
                });
                // --- END: Modify querySelectorAll ---

                offcanvasSidePanel.querySelectorAll('label[for]').forEach(label => {
                    label.htmlFor = label.htmlFor + '-drawer'; // point labels at the new drawer IDs
                });

                // NEW: sync checked state from main panel to drawer
                offcanvasSidePanel.querySelectorAll('input[type="checkbox"][data-sync-id]').forEach(drawerCb => {
                    const mainCb = document.getElementById(drawerCb.dataset.syncId);
                    if (mainCb) drawerCb.checked = mainCb.checked;
                });

                // --- START: Sync Select Values (Price, Date, SubCategory) ---
                ['priceFilter', 'dateFilter', 'subCategoryFilter'].forEach(selectId => {
                    const mainSelect = document.getElementById(selectId);
                    const drawerSelect = offcanvasSidePanel.querySelector(`select[data-sync-id="${selectId}"]`); // Find by data-sync-id
                    if (mainSelect && drawerSelect) {
                        drawerSelect.value = mainSelect.value; // Set drawer value to match main value
                    }
                });
                // --- END: Sync Select Values ---


                // --- START: Re-initialize sliders specifically for the drawer ---
                // Find all slider elements within the newly populated drawer
                const drawerSliders = offcanvasSidePanel.querySelectorAll('.range-slider[id]');
                drawerSliders.forEach(drawerSlider => {
                    // --- START: ensure unique IDs for drawer sliders ---
                    const originalId = drawerSlider.id;
                    drawerSlider.dataset.syncSliderId = originalId;        // remember original ID
                    drawerSlider.id = originalId + '-drawer';              // new unique ID
                    const sliderId = drawerSlider.dataset.syncSliderId;    // use original ID for lookup
                    // --- END: ensure unique IDs ---

                    const mainSlider = document.getElementById(sliderId); // Find original slider

                    // Check if the original slider was initialized and has a config
                    if (mainSlider && mainSlider.noUiSlider && sliderConfigs[sliderId]) {
                        const config = sliderConfigs[sliderId];
                        // --- Correctly query value displays (IDs likely unchanged) ---
                        const minValDisplay = offcanvasSidePanel.querySelector(`#${sliderId}-val-min`);
                        const maxValDisplay = offcanvasSidePanel.querySelector(`#${sliderId}-val-max`);
                        
                        // --- START: Correctly query hidden inputs using their MODIFIED drawer IDs ---
                        const inputMin = offcanvasSidePanel.querySelector(`input[id="${config.inputs[0]}-drawer"]`); 
                        const inputMax = offcanvasSidePanel.querySelector(`input[id="${config.inputs[1]}-drawer"]`);
                        // --- END: Corrected query selectors ---

                        if (drawerSlider && inputMin && inputMax) { // Check if drawer slider AND the correct inputs were found
                             // Destroy existing slider instance if present (important for re-sync)
                             if (drawerSlider.noUiSlider) {
                                drawerSlider.noUiSlider.destroy();
                             }
                             // Clear existing content to prevent duplicate slider bars
                             drawerSlider.innerHTML = '';
                            // Create a new slider instance in the drawer
                            noUiSlider.create(drawerSlider, {
                                start: mainSlider.noUiSlider.get(), // Start with the main slider's current value
                                connect: true,
                                step: config.step,
                                range: config.range,
                                format: config.format,
                                behaviour: 'tap-drag',
                                tooltips: false
                            });

                            // Update drawer display/inputs when drawer slider changes
                            drawerSlider.noUiSlider.on('update', (values) => {
                                const [minVal, maxVal] = values;
                                if (minValDisplay) minValDisplay.textContent = minVal;
                                if (maxValDisplay) maxValDisplay.textContent = maxVal;
                                inputMin.value = minVal;
                                inputMax.value = maxVal;
                            });

                            // When drawer slider *finishes* changing, update the *main* slider and apply filters
                            drawerSlider.noUiSlider.on('change', (values) => {
                                mainSlider.noUiSlider.set(values); // Sync back to main slider
                                debouncedApplyFilters(); // Use debounced version as slider changes can be frequent during drag
                            });

                             // Set initial display values in the drawer
                             const initialValues = drawerSlider.noUiSlider.get();
                             if (minValDisplay) minValDisplay.textContent = initialValues[0];
                             if (maxValDisplay) maxValDisplay.textContent = initialValues[1];
                        }
                    }
                });
                 // --- END: Re-initialize sliders specifically for the drawer ---

            } else {
                offcanvasSidePanel.innerHTML = ''; // Clear drawer on desktop
            }
        }

        function openDrawer() {
            syncSidePanelToDrawer();              // clone structure & set IDs
            drawer.classList.add('active');
            overlay.classList.add('active');
            document.body.classList.add('offcanvas-open');

            setTimeout(() => drawer.focus(), 100);
        }
        function closeDrawer() {
            drawer.classList.remove('active');
            overlay.classList.remove('active');
            document.body.classList.remove('offcanvas-open');
        }
        if (filterBtn) filterBtn.addEventListener('click', openDrawer);
        if (closeBtn) closeBtn.addEventListener('click', closeDrawer);
        if (overlay) overlay.addEventListener('click', closeDrawer);

        document.addEventListener('keydown', function(e) {
            if (drawer.classList.contains('active') && (e.key === 'Escape' || e.key === 'Esc')) {
                closeDrawer();
            }
        });

        // --- START: Delegated Event Listener for Drawer ---
        if (drawer) {
            drawer.addEventListener('change', function(event) {
                const target = event.target;

                // Ignore changes if they don't have an ID we can match or aren't relevant filter inputs
                if (!target.id || !['INPUT', 'SELECT'].includes(target.tagName)) {
                    return;
                }

                // Sliders are handled by their own 'change' event added during syncSidePanelToDrawer
                if (target.closest('.noUi-base')) {
                    return;
                }

                const mainId = target.dataset.syncId || target.id;      // prefer original ID if set
                const mainElement = document.getElementById(mainId);

                if (!mainElement) {
                     return; // Cannot sync if main element doesn't exist
                }

                // Sync state from drawer element (target) to main element
                if (target.type === 'checkbox') {
                    mainElement.checked = target.checked;

                    // Specific logic for Country checkboxes within the drawer
                    const countryListItem = target.closest('.country-list > li');
                    // Check if the target is the direct country checkbox (not a city checkbox)
                    if (countryListItem && target.id === countryListItem.querySelector('div > input[type="checkbox"]')?.id) {
                        const cityListInDrawer = countryListItem.querySelector('.city-list');
                        if (cityListInDrawer) {
                            cityListInDrawer.style.display = target.checked ? 'block' : 'none';
                            // If country is unchecked in drawer, uncheck corresponding cities in main panel AND drawer
                            if (!target.checked) {
                                const mainCityList = mainElement.closest('li')?.querySelector('.city-list');
                                if (mainCityList) {
                                    mainCityList.querySelectorAll('input[type="checkbox"]').forEach(mainCityCb => {
                                        mainCityCb.checked = false;
                                    });
                                }
                                // Also uncheck cities within the drawer itself
                                cityListInDrawer.querySelectorAll('input[type="checkbox"]').forEach(drawerCityCb => {
                                    drawerCityCb.checked = false;
                                });
                            }
                        }
                    }
                    // No specific UI action needed here for city checkboxes within the drawer,
                    // as their state is synced to the main element which applyFilters reads.

                } else if (target.tagName === 'SELECT') {
                     if (target.multiple) {
                         // Sync selected options for multi-select
                         const selectedValues = Array.from(target.selectedOptions).map(opt => opt.value);
                         Array.from(mainElement.options).forEach(mainOpt => {
                             mainOpt.selected = selectedValues.includes(mainOpt.value);
                         });
                     } else {
                         // Sync value for single select
                         mainElement.value = target.value;
                     }
                } else if (target.type === 'date' || target.type === 'number' || target.type === 'text') {
                     // Sync value for text-based inputs
                     mainElement.value = target.value;
                }
                 // Add other types if necessary

                // After syncing the main element, trigger the filter application
                // applyFilters reads from the main elements, which are now up-to-date
                applyFilters(); // Use non-debounced for immediate feedback on simple controls
            });
        }
        // --- END: Delegated Event Listener for Drawer ---

        // Always sync on resize (in case filters change or viewport crosses breakpoint)
        window.addEventListener('resize', syncSidePanelToDrawer);
        // Sync drawer content initially on load (important if starting on mobile view)
        window.addEventListener('DOMContentLoaded', syncSidePanelToDrawer);

        // Add resize listener to re-evaluate margin on screen size change
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Re-run the display logic which includes the margin calculation
                updateActiveFiltersDisplay();
            }, 150); // Debounce resize event
        });

    })();

}); 
</script>
</body>
</html>